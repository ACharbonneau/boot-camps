----------------------------------------------------------------------
Python 6: Classes and Objects 
----------------------------------------------------------------------


[[Back to Strings and File I-O | Python-5:-Strings-and-File-I-O ]] - [[Forward 
to Python7-SciPy | SciPy ]]

----


.........................................................................
 Basic Classes 
.........................................................................


The file manipulation example in the last lecture hid a pretty amazing idea. When we opened a file using open(), it returned a new type we hadn't seen before. The type had methods that we could use to access the file all at once or one character at a time. It had other methods to move around in the file, to close it, and to update it. It also had data: what file is open and where in the file is the next readable byte. The magic is that you, the programmer, don't have to think about the details of the file implementation. You just have to use the methods available to access the file. This thought process is the basis of objects and object oriented programming.


Object oriented (OO) programming revolves around the create and manipulation of 
objects that have attributes and can do things.  They can be as simple as a 
coordinate with x and y values or as complicated as a dynamic webpage framework.  
They are a useful way to organize programs.  C++ and Java are OO languages.  
Even fortran is adding OO constructs in newer standards.  Here is the code for making a very simple 
class that sets an attribute.  Start a new file, call it myclass.py and type 
this in.

::

  class MyClass(object):
    def setA(self, A):
      self.A = A
  

 * Explicit is better than implicit - all python class functions (methods) 
   explicitly pass the object they work on.
 * Simple is better than complicated - class variables (attributes) can be 
   directly accessed and dynamically created
 * Namespaces are one honking great idea -- let's do more of those! - Notice the 
   similarity of accessing functions in a module and object attributes/functions

You create a !MyClass object and play around with it.  Instances of a class are 
instantiated by calling the class like a function.  a = !MyClass()
 * create a !MyClass
 * ask its type
 * set A using setA
 * directly set A
 * what types are fair game for A?
 * add an attribute B to an instance of a !MyClass

Vocabulary time
 * Class - user defined type (!MyClass)
 * object - instance of a Class (tmp = !MyClass(), tmp is an object)
 * method - a Class function, also called a member function (tmp.getA())
 * attribute - a Class variable (tmp.A)
 * Duck typing - if it behaves like a duck, who cares if 
   type(a)== 'Duck'?



**Hands on Example**

Write a !PhoneNumber class with functions set_number(number_string) and 
area_code().

::
  
  #!CodeExample
  #!python
  """phonenum defines function for manipulating phone number strings"""
  
  print "Nudge, nudge, wink, wing, say no more, say no more!"
  
  class PhoneNumber(object):
      """I am a phone number"""
      
      def set_phone_number(self, phone_string):
          """format_phone_number formats a string in the format 'xxx-xxx-xxxx'
      to 'xxx-xxx-xxxx'"""
          
          formatted_string = ''
          for char in phone_string:
              if char in '0123456789':
                  formatted_string += char
          self.phone_number = formatted_string
  
      def area_code(self):
          """area_code returns the area code from a properly formatted
      phone number string"""
          return self.phone_number[0:3]
  

.........................................................................
 Constructors 
.........................................................................


Usually you want to create an object with a set of initial values for things.  
Perhaps an object needs certain information to be created.  For this you write a 
"constructor."  In python, constructors are just methods with a special name: 
!__init!__.  !MyClass(stuff) -> !__init!__(self, stuff).  

**Aside: Magic functions**

Methods with leading and trailing double underscores are "magic functions" in 
python.  If you go to the [Session09 Advanced Python] breakout session you will 
learn more about them.
  * Iteration (for x in sequence) uses !__next!__
  * Slicing ie brackets) (a[1:2]) uses !__get!__
  * Calling ie parentheses (a(3)) uses !__call!__
  * Help uses !__doc!__


Convert your set_number function to be a constructor.


**Aside: Old vs New Style Classes**

It is worth noting that there are two types of classes in python: Old style 
classes (OSC) and new style classes (NSC).  NSC fix some conceptual problems 
with OSC (typing, diamond inheritance, subclassing built in types, etc).  
Consequently OSC are gone in python 3.  This is not a cause for concern or 
confusion as the difference are subtle and will not affect you until you have 
written enough python to be comfortable with the distinction.  Or you can always 
subclass object and render the issue moot.  Below illustrates the fix in the 
typing system.

::

  #!CodeExample
  #!python
  class OldStyleClass: # don't use this one
      def __init__(self):
          print "Old Style"
  
  class NewStyleClass(object): # <- use this one
      def __init__(self):
          print "New Style"
  
  ns = NewStyleClass()
  os = OldStyleClass()
  
  print type(os)
  print type(ns)
  
  
  
.........................................................................
 Class methods with variable numbers of arguments 
.........................................................................


In the previous session you learned about the power of python functions.  The 
full power of functions (keyword arguments, variable length arguments, etc) are 
available in classes.  For converts from other languages, be aware that python 
functions do not have a type signature so function overloading is not available.

.........................................................................
 Subclassing 
.........................................................................


If you want a to create a Class that behaves mostly like another class, you 
should not have to copy code.  What you do is subclass and change the things 
that need changing.  When we created classes we were already subclassing the 
built in python class "object."

Python guidelines for code formatting and pythonic conventions on class 
behavior, naming, etc.
[http://www.python.org/dev/peps/pep-0008/ python conventions]
