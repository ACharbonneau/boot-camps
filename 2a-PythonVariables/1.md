# Python, iPython, and the basics

In this lecture, i'm going to talk about programming; specifically the python programming language. In order to do the examples, we are going to have to use an environment called iPython which I'll also talk about. I expect this lecture to be interactive, so stop me at any point if you have questions. Finally, I want everyone to understand that fundamentally computing is about people. The correct power dynamic is that people are the mastes and the machines are servants. The machines are there to make our lives easier. Programming is an act of written communication between people across time and space. Computers are just the medium.

This lecture will be structured as follows: I will be teaching the basics of two things: the python programming language (to a greater extent) and the ipython interpreter (to a lesser extent). The ipython interpreter is one of many different ways to implement python code. As far as the python component, I'll shoot for a layered approach: I'l continue building on my previous concepts. It turns out that like any sufficiently complex topic, its not really possible to force the pedagogy into a serial stream. Also, we have a pretty serious time constraint. I'm just going to drop it on you. Because of the brief nature of this tutorial, I've included links to some excellent reference material. Also, if we have time, I'll take questions based on the specific programming needs of this class.

Here is the reference material.

* Dive into Python
* Software Carpentry's Python Lectures
* iPython journal paper
* How to Think Like a Computer Scientist

Once we briefly deal with ipython, I'll cover python in the following order:

* print statements
* variables
* integers
* floats
* strings
* types
* type coersion
* basic operations: add numbers, concatenate strings, basic data type functionality

* list
* dictionary 
* set 
* tuple
* file reading

* for loop
* conditional (if) statements
* while loops
* iteration
* writing to files

* methods
* modules

## iPython
ipython is the tool that we are going to use to execute python commands and code. iPython is an alternative to the built-in Python interpreter with some nice features. Lets give the built-in interpreter a spin just this once.

$ python
>>> print "hello world"
hello world
>>> quit()

We can also write python commands in a file and execute them from the command line. You will notice that the print command above is located in the file hello.py. Execute the following command at the command line

$ python hello.py

iPython has more useful features than the standard python interpreter, so we'll use it from here on out.

$ ipython
>>> print "hello world"
hello world

### Pasting

You can paste things into the ipython console by copying text from your machine and typing %paste at the iPython prompt. Try printing this block of text using the print command.

>>> %paste

### History

iPython has a history. If you press the up and down keys, you can access the history.

### Tab Completion

iPython also has tab completion of previous commands. Try typing "print" and then hit the tab key.

### Getting Help

iPython also has a help feature. Lets say we want to know more about the integer data type. There are at least two ways to do this task:

help(int)

int?

If you wanted to see all the commands available for something, use the dir command. Check out all of the methods of the str type.

dir(str)

### Executing code in files

If your code is in a file, you can execute it from the iPython shell with the %run command. Execute hello.py like so

%run hello.py

### Clearing iPython

To clear everything from iPython, use the reset command.

>>> reset

## Variables

All programming languages have variables, and python is no different. To create a variable, just name it and set it with the equals sign. One important caveat: variable names can only contain letters, numbers, and the underscore character. Lets set a variable.

experiment = "current vs. voltage"
print experiment

voltage = 2
current = 0.5

print voltage, current

## Types and Dynamic Typing

Like most programming languages, things in python are typed. The type refers to the type of data. We've already defined three different types of data in experiment, voltage, and current. The types are string, integer, and float. You can inspect the type o fa variable by using the type command.

type(experiment)
str
type(voltage)
int
type(current)
float

Python is a dynamically typed language (unlike, say, C++). If you know what that means, you may be feeling some fear and loathing right now. If you don't know what dynamic typing means, the next stuff may seem esoteric and pedantic. Its actually important, but its importance may not be clear to you until long after this class is over.

Dynamic typing means that you don't have to declare tye type of a variable when you define it; python just figures it out based on how you are setting the variable. Lets say you set a variable. Sometime later you can just change the type of data assigned to a variable and python is perfectly happy about that. Since it won't be obvious until (possibly much) later why that's important, I'll let you marinate on that idea for a second. 

Here's an example of dynamic typing. What's the type of data assigned to voltage?

type(voltage)
int

Lets assign a value of 2.7 (which is clearly a float) to voltage. What happens to the type?

voltage = 2.7
type(voltage)
float

You can even now assign a string to the variable voltage and python would be happy to comply.

voltage = "2.7 volts"
type(voltage)
str

I'll let you marinate on the pros and cons of this construction while I change the value of voltage back to an int:

voltage = 2

## Assigning Variables to Other Variables

a = 1
b = a
a = 2
print b

## Coersion
It is possible to coerce (a fancy and slightly menacing way to say "convert") certain types of data to other types. For example, its pretty straightforward to coerce numerical data to strings.

voltageString = str(voltage)
currentString = str(current)
voltageString
type(voltageString)
str
currentString
type(currentString)
str

As you might imagine, you can go the other way in certain cases. Lets say you had numerical data in a string.

resistanceString = "4.0"
resistance = float(resistanceString)
resistance
type(resistance)
float

What would happen if you tried to coerce resistanceString to an int? What about coercing resistance to an int? Consider the following:

resistanceString = "4.0 ohms"

Do you think you can coerce that string to a numerical type?

## On Being Precise with floats and ints

Again, the following may seem esoteric and pedantic, but it is very important. So bear with me.

Lets say you had some voltage data that looks like the following

0
0.5
1
1.5
2

Obviously, if you just assigned this data individually to a variable, you'd end up with the following types

0   -> int
0.5 -> float
1   -> int
1.5 -> float
2   -> int

But what if you wanted all of that data to be floats on its way in? You could assign the variable and then coerce it to type float:

voltage = float(1)

But that's ugly. If you want whats otherwise an integer to be a float, just add a period at the end

voltage = 1.
type(voltage)
float

This point becomes important when we start operating on data in the next section.

## Data Operations

In this section all of the discussion in the previous section becomes important. I don't know if I'd call this stuff fundamental to the language, but its pretty important and it will zing you if you aren't careful. The takeaway is that you need to be precise with what you are doing. Lets say you want to add some integers.

a = 1
b = 2
c = a + b
c
type(a,b,c)
int, int, integer
So we got a vale of three for the sum, which also happens to be an integer. Any operation between two integers is another integer. Makes sense.

So what about the case where a is an integer and b is a float?

a = 1
b = 2.
c = a + b
c
type(a,b,c)
int, float, float

You can do multiplication on numbers as well.

a = 2
b = 3
c = a * b
c
type(a,b,c)
int, int, int

Also division.

a = 1
b = 2
c = a/b
c
type(a,b,c)
int, int, int

ZING!

Here's why type is important. Divding two integers returnes an integer: this operation calculates the quotient and floors the result to get the answer.

If everything was a float, the division is what you would expect.

a = 1.
b = 2.
c = a/b
c
type(a,b,c)
float, float, floats

There are operations that can be done with strings.

firstName = "Joshua"
lastName = "Smith"
fullName = firstName + lastName
fullName

When concatenating strings, you have to be explicit since computers don't understand context.

fullName = firstName + " " + lastName
fullName

There are other operations deined on string data. Use the dir comnand to find them. One example I'll show is the upper method. Lets take a look at the documentation.

str.upper?

So we can use it to upper-caseify a string. 

fullName.upper()
JOSHUA SMITH

You have to use the parenthesis at the end because upper is a method of the string class.

For what its worth, you don't need to have a variable to use the upper() method, you could use it on the string itself.

"Joshua Smith".upper()
JOSHUA SMITH

That wraps up this lesson. We tried out the iPython shell and got some experience with ints, floats, and strings. Along the way we talked about some philosophy and how programming is about people.